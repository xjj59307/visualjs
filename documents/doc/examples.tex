\chapter {Examples}
\label {Examples}

To best explain how VisualJS converts an object to visual shapes, some typical examples will be talked below. The first example is about quick sort algorithm and the data structure defined in an array will be visualized by a bar chart. The second example is about the AVL tree to show the other data structure, tree, supported by the system. The last example is about the math expression tree. Since the nodes of the math expression tree are divided into operator type and operand type, and the operator type can still be divided into several types. Users may want to customize the appearance of each type. This example embodies the flexibility of VisualJS language.

\section {Quick Sort}

The first example considers a quick sort implementation in JavaScript. Quicksort, like merge sort, is based on the divide-and-conquer paradigm \cite{Cormen:2001:IA:580470}. The three steps of the process for sorting a array $A[p..r]$ is as follows:

\begin {enumerate}
\item \textbf{Divide:} Partition the array $A[p..r]$ into two subarrays $A[p..q-1]$ and $A[q+1..r]$ such that each element of $A[p..q-1]$ is less that or equal to $A[q]$, which is less than or equal to each element of $A[q+1..r]$. The index $q$ is usually called pivot.
\item \textbf{Conquer:} Sort the two subarrays by recursively calling quicksort.
\item \textbf{Combine:} Since the two subarrays have been sorted, the entire array is also sorted. 
\end {enumerate}

The following JavaScript code implements quicksort \cite{1981455}.

\begin{lstlisting}[language=JavaScript]
var Quicksort = (function() {
  function swap(array, indexA, indexB) {
    var temp = array[indexA];
    array[indexA] = array[indexB];
    array[indexB] = temp;
  }

  function partition(array, pivot, left, right) {
    var storeIndex = left;
    var pivotValue = array[pivot].value;
    swap(array, pivot, right);
 
    for(var v = left; v < right; v++) {
      if(array[v].value < pivotValue) {
        swap(array, v, storeIndex);
        storeIndex++;
      }
    }

    swap(array, right, storeIndex);
    return storeIndex;
  }
 
  function sort(array, left, right) {
    var pivot = null;
 
    if(typeof left !== 'number') { left = 0; }

    if(typeof right !== 'number') { right = array.length - 1; }

    if(left < right) {
      pivot = left + Math.ceil((right - left) * 0.5);
      newPivot = partition(array, pivot, left, right);
      sort(array, left, newPivot - 1);
      sort(array, newPivot + 1, right);
    }
  }

  return { sort: sort };
})();

var array = [];
for(var i = 0; i < 20; i++) {
  var value = Math.round(Math.random() * 100);
  array.push({ value: value });
}

Quicksort.sort(array);
\end{lstlisting}

As shown in the source code, the data to be sorted is stored in an array, and the data structure of the array element is defined as follows:

\begin{lstlisting}[language=JavaScript]
{
	"value": <number>
}
\end{lstlisting}

We can write the VisualJS code just by the data structure definition. Because the VisualJS code is interpreted dynamically, users can modify the VisualJS code along with debugging. The VisualJS code used in this example is written as follows:

\begin{lstlisting}
array: pattern {
  exec array when (self instanceof Array),
  exec element when (typeof self === 'object')
}

array: action {
  foreach_next()
}

element: action {
  create bar(value = self.value)
}
\end{lstlisting}

Since the source code and the VisualJS code have been prepared, we can generate the visualization of the data structure and make it animated while stepping through the program. We find that function partition is very bug-prone on account of its complex logic. We can investigate this function with different granularities.

Figure \ref{fig: Before partition} and Figure \ref{fig: After partition} show the visualizations of parameter \textit{array} before and after function partition being called. These two visualizations can help us verify the correctness of function partition on a high level. The new pivot element generated by function partition is highlighted in the second figure with red border. We can intuitively find that the new pivot element satisfied the definition in the algorithm description. All left elements are less than or equal to it and all right element are larger than or equal to it.

\begin{figure}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/quicksort-1}
    \caption{Before partition}
    \label{fig: Before partition}
  \end{center}
  \end{minipage}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/quicksort-2}
    \caption{After partition}
    \label{fig: After partition}
  \end{center}
  \end{minipage}
\end{figure}

If we found any suspicious action of the function, we could step into the function and observe the visualizations step by step to find out where the bug is.

\section {AVL Tree}

The second example is about AVL tree. AVL tree is a binary search tree that is height balanced \cite{Cormen:2001:IA:580470}. For each node, the heights of the left and right subtrees differ by at most 1. Please refer to the implementation in Appendix \ref{AVL Tree Source Code} \cite{2424106}.

As shown in the source code, the data structure of the tree node is defined as follows:

\begin{lstlisting}[language=JavaScript]
{
  "attr"    : <string>,
  "left"    : <tree node>,
  "right"   : <tree node>,
  "node"    : <Object>,
  "depth"   : <number>,
  "elements": [<Object>, ...]
}
\end{lstlisting}

From the definition of the tree node, we can write the VisualJS code as follows:

\begin{lstlisting}
operator: pattern {
  exec avltree_node
}

avltree_node: action {
  create node=tree_node(label = self.node[self.attr]),
  create tree_edge(from = parent, to = node),
  next self.left(parent = node),
  next self.right(parent = node)
}
\end{lstlisting}

New tree nodes can be added by calling add function. To verify the correctness of this function, we can make use of the balance property of AVL tree. The tree must keep balance each time new tree node is added. From Figure \ref{fig: step 1} to Figure \ref{fig: step 6}, six nodes are added to the AVL tree. Since the AVL tree always satisfies the property of self-balancing binary search tree, we can basically believe that add function is bug-free.

\begin{figure}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/avl-tree-1}
    \caption{step 1}
    \label{fig: step 1}
  \end{center}
  \end{minipage}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/avl-tree-2}
    \caption{step 2}
    \label{fig: step 2}
  \end{center}
  \end{minipage}
\end{figure}

\begin{figure}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/avl-tree-3}
    \caption{step 3}
    \label{fig: step 3}
  \end{center}
  \end{minipage}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/avl-tree-4}
    \caption{step 4}
    \label{fig: step 4}
  \end{center}
  \end{minipage}
\end{figure}

\begin{figure}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/avl-tree-5}
    \caption{step 5}
    \label{fig: step 5}
  \end{center}
  \end{minipage}
  \begin{minipage}{0.5\hsize}
  \begin{center}
    \includegraphics[width=0.9\hsize,clip]{img/avl-tree-6}
    \caption{step 6}
    \label{fig: step 6}
  \end{center}
  \end{minipage}
\end{figure}

\section {Math Expression Tree}

The third example is about math expression tree. The Math Expression Tree is a specific application of a binary tree to express certain math expressions. All leaves of this tree are operands, and the other nodes contain four-type operators, plus, minus, times, and divide. The following JavaScript code generates a math expression tree.

\begin{lstlisting}[language=JavaScript]
var generate = function(depth) {
  if (depth > 1) return { value: 1 };

  var operator = Math.floor(Math.random()*10) % 4;
  return {
    op: operator,
    left: generate(depth+1),
    right: generate(depth+1)
  };
};

var node = generate(0);
\end{lstlisting}

As shown in the source code, the data structure of the tree node is defined as follows:

\begin{lstlisting}[language=JavaScript]
{
  "op"   : <number>,
  "left" : <tree node>,
  "right": <tree node>
}
\end{lstlisting}

Operator type nodes are classified by its op field, which uses 0 to represent plus, 1 to represent minus, 2 to represent times, and 3 to represent divide. It seems to be a reasonable definition in consideration of extendability of the data structure. However, an integer is not enough intuitional to be associated with an operator. VisuslJS can help users visualize the math expression tree in any shape they conceive. We can write the VisualJS code as follows. Each action customizes the appearance of certain operator or operand node.

\begin{lstlisting}
operator: pattern {
  exec plus when (self.op === 0),
  exec minus when (self.op === 1),
  exec times when (self.op === 2),
  exec divide when (self.op === 3),
  exec value when (typeof self.value === 'number')
}

plus: action {
  create node=tree_node(label = '+'),
  create tree_edge(from = parent, to = node),
  next self.left(parent = node),
  next self.right(parent = node)
}

minus: action {
  create node=tree_node(label = '-'),
  create tree_edge(from = parent, to = node),
  next self.left(parent = node),
  next self.right(parent = node)
}

times: action {
  create node=tree_node(label = '*'),
  create tree_edge(from = parent, to = node),
  next self.left(parent = node),
  next self.right(parent = node)
}

divide: action {
  create node=tree_node(label = '/'),
  create tree_edge(from = parent, to = node),
  next self.left(parent = node),
  next self.right(parent = node)
}

value: action {
  create node=tree_node(label = self.value),
  create tree_edge(from = parent, to = node)
}
\end{lstlisting}

Figure \ref{fig: math expression tree} shows the visualization result of the math expression tree.

\begin{figure}
  \begin{center}
    \includegraphics[width=1.0\hsize,clip]{img/math-expression-tree}
    \caption{The visualization result of the math expression tree}
    \label{fig: math expression tree}
  \end{center}
\end{figure}
